/*

A device is secured with a digital screen, 
The digital screen is made up of a 3*3 grid like below:
| 1 | 2 | 3 |
| 4 | 5 | 6 |
| 7 | 8 | 9 |

The code is generated by connecting the keys in a valid way using the grid.

Rules to create the valid codes are as follows:
	- Each code must consist of atleast m keys and atmost n keys.
	- All the keys must be distinct.
	- If the line connecting two consecutive keys 'A','B' in the code passes 
	  through any other key C, then 'C' must have already connected priorly, 
	  as a part of the code. No jumps through a key which is not part of 
	  the code are allowed.
	- The order of keys used matters.
 
You will be given two integers m and n, where 1 ≤ m ≤ n ≤ 9, 
Your task is to count the total number of valid codes can be created to 
sefeguard the device, which consist of minimum of m keys and maximum n keys. 

Examples of valid and invalid codes:
	Invalid code: 1 - 2 - 7 - 9
	Line 7 - 9, passes through key 8 which has not been part of the code.
	i.e., 1 - 2 - 7 - 9 - 8 is also an invalid code.

	Invalid code: 1 - 8 - 3 - 7
	Line 3 - 7 passes through key 5 which has not been part of the code.

	Valid code: 5 - 7 - 4 - 6 - 9   
	Line 4 - 6 is valid because it passes through key 5, which has been part 
	of the code

	Valid code: 4 - 5 - 6 - 3 - 7 - 2
	Line 3 - 7 is valid because it passes through key 5, which has been part 
	of the code

Input Format:
-------------
Two space separated integers M and N.

Output Format:
--------------
Print an integer, number of valid codes created using the digital screen.


Sample Input-1:
---------------
1 1

Sample Output-1:
----------------
9


Sample Input-2:
---------------
1 2

Sample Output-2:
----------------
65

*/

#include<bits/stdc++.h>
using namespace std;

int dfs(int num, int len, int m, int n, vector<vector<int>>& jumps,vector<bool> visited, int res) {
    if (len >= m) ++res;
    ++len;
    if (len > n) return res;
    visited[num] = true;
    for (int next = 1; next <= 9; ++next) {
        int jump = jumps[num][next];
        if (!visited[next] && (jump == 0 || visited[jump])) {
            res = dfs(next, len, m, n, jumps, visited, res);
        }
    }
    visited[num] = false;
    return res;
}

int main(){
    int m,n;
    cin>>m>>n;
    int res = 0;
    vector<bool> visited(10,false);
    vector<vector<int>> jumps(10,vector<int> (10,0));
    jumps[1][3] = jumps[3][1] = 2;
    jumps[4][6] = jumps[6][4] = 5;
    jumps[7][9] = jumps[9][7] = 8;
    jumps[1][7] = jumps[7][1] = 4;
    jumps[2][8] = jumps[8][2] = 5;
    jumps[3][9] = jumps[9][3] = 6;
    jumps[1][9] = jumps[9][1] = jumps[3][7] = jumps[7][3] = 5;
    res += dfs(1, 1, m, n, jumps, visited, 0) * 4;
    res += dfs(2, 1, m, n, jumps, visited, 0) * 4;
    res += dfs(5, 1, m, n, jumps, visited, 0);
    cout<<res;
    return 0;
}
